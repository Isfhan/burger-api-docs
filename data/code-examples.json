{
  "basic": "import { Burger } from \"burger-api\";\n\n// Global middleware example: a simple logger.\nconst globalLogger = async (req, res, next) => {\n  console.log(`[Global Logger] ${req.method} ${req.url}`);\n  return next();\n};\n\nconst burger = new Burger({\n  title: \"My Custom API\",\n  description: \"Custom API with auto-generated docs and validation\",\n  apiDir: \"api\",\n  globalMiddleware: [globalLogger],\n  version: \"1.0.0\",\n  debug: true, // Enable debug mode for detailed logging and stack trace page\n});\n\n// Start the server on port 4000 with a callback\nburger.serve(4000, (port) => {\n  console.log(`Server is running on port ${port}`);\n});",
  "structure": "my-api/\n├── src/\n│   ├── api/                    # API routes\n│   │   ├── products/\n│   │   │   ├── route.ts       # Product routes\n│   │   │   └── [id]/\n│   │   │       └── route.ts   # Product detail routes\n│   │   └── users/\n│   │       └── route.ts       # User routes\n│   ├── middleware/            # Middleware\n│   │   ├── global/           # Global middleware\n│   │   │   ├── logger.ts\n│   │   │   └── auth.ts\n│   │   └── routes/           # Route-specific middleware\n│   │       ├── products.ts\n│   │       └── users.ts\n│   ├── schemas/              # Zod schemas\n│   │   ├── product.ts\n│   │   └── user.ts\n│   ├── utils/               # Utility functions\n│   │   ├── errors.ts\n│   │   └── helpers.ts\n│   └── index.ts             # Main application file\n├── package.json\n└── tsconfig.json",
  "middleware": {
    "global": "import type { BurgerRequest, BurgerResponse } from \"burger-api\";\n\nexport const logger = async (req: BurgerRequest, res: BurgerResponse, next: () => Promise<Response>) => {\n  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);\n  return next();\n};",
    "route": "import type { BurgerRequest, BurgerResponse } from \"burger-api\";\n\nexport const validateProductAccess = async (\n  req: BurgerRequest,\n  res: BurgerResponse,\n  next: () => Promise<Response>\n) => {\n  // Check if user has access to the product\n  // For example, verify authentication token or check permissions\n  \n  // If validation fails, return an error response\n  // return res.status(403).json({ error: \"Access denied\" });\n  \n  // If validation passes, continue to the next middleware or route handler\n  return next();\n};"
  },
  "schemas": "import { z } from \"zod\";\n\nexport const productSchema = {\n  create: z.object({\n    name: z.string().min(1),\n    price: z.number().positive(),\n    description: z.string().optional(),\n    category: z.enum([\"electronics\", \"clothing\", \"food\", \"other\"]),\n    inStock: z.boolean().default(true),\n    \n    tags: z.array(z.string()).optional(),\n  }),\n  update: z.object({\n    name: z.string().min(1).optional(),\n    price: z.number().positive().optional(),\n    description: z.string().optional(),\n    category: z.enum([\"electronics\", \"clothing\", \"food\", \"other\"]).optional(),\n    inStock: z.boolean().optional(),\n    tags: z.array(z.string()).optional(),\n  }),\n};",
  "routes": "import type { BurgerRequest, BurgerResponse } from \"burger-api\";\nimport { validateProductAccess } from \"../../middleware/routes/products\";\nimport { productSchema } from \"../../schemas/product\";\n\n// OpenAPI metadata for this route\nexport const openapi = {\n  get: {\n    summary: \"List Products\",\n    description: \"Retrieves a list of all products with optional filtering.\",\n    tags: [\"Products\"],\n    operationId: \"listProducts\",\n  },\n  post: {\n    summary: \"Create Product\",\n    description: \"Creates a new product with the provided data.\",\n    tags: [\"Products\"],\n    operationId: \"createProduct\",\n  }\n};\n\n// Route-specific middleware\nexport const middleware = [validateProductAccess];\n\n// Validation schemas\nexport const schema = {\n  post: {\n    body: productSchema.create,\n  },\n  put: {\n    body: productSchema.update,\n  },\n};\n\nexport async function GET(req: BurgerRequest, res: BurgerResponse) {\n  // Get query parameters\n  const query = req.validated?.query || Object.fromEntries(req.query.entries());\n  \n  // In a real app, you would fetch products from a database\n  return res.json({ \n    message: \"List of products\", \n    filters: query,\n    products: [\n      { id: 1, name: \"Product 1\", price: 99.99 },\n      { id: 2, name: \"Product 2\", price: 149.99 }\n    ] \n  });\n}\n\nexport async function POST(req: BurgerRequest, res: BurgerResponse) {\n  // req.validated.body contains the validated request body\n  const body = req.validated?.body;\n  \n  // In a real app, you would save the product to a database\n  return res.json({ \n    message: \"Product created\", \n    data: body \n  });\n}",
  "main": "import { Burger } from \"burger-api\";\nimport { logger } from \"./middleware/global/logger\";\n\nconst burger = new Burger({\n  title: \"Product API\",\n  description: \"API for managing products\",\n  apiDir: \"api\",\n  globalMiddleware: [logger],\n  version: \"1.0.0\",\n  debug: process.env.NODE_ENV !== \"production\", // Enable debug mode in development\n});\n\nconst PORT = process.env.PORT ? parseInt(process.env.PORT) : 4000;\n\nburger.serve(PORT, (port) => {\n  console.log(`Server is running on port ${port}`);\n  console.log(`API Documentation: http://localhost:${port}/docs`);\n  console.log(`OpenAPI Spec: http://localhost:${port}/openapi.json`);\n});",
  "advanced": "// examples/demo/api/product/[id]/route.ts\n\nimport { z } from \"zod\";\nimport type { BurgerRequest, BurgerResponse } from \"burger-api\";\n\n// OpenAPI metadata for this route\nexport const openapi = {\n  get: {\n    summary: \"Get Product Details\",\n    description: \"Retrieves product details by product ID.\",\n    tags: [\"Product\"],\n    operationId: \"getProductDetails\",\n  },\n  put: {\n    summary: \"Update Product\",\n    description: \"Updates an existing product by ID.\",\n    tags: [\"Product\"],\n    operationId: \"updateProduct\",\n  },\n  delete: {\n    summary: \"Delete Product\",\n    description: \"Deletes a product by ID.\",\n    tags: [\"Product\"],\n    operationId: \"deleteProduct\",\n  }\n};\n\n// Validation Schemas for GET and POST requests\nexport const schema = {\n  get: {\n    params: z.object({\n      id: z.preprocess(\n        (val) => (typeof val === \"string\" ? parseInt(val, 10) : val),\n        z.number().min(1, \"ID is required\")\n      ),\n    }),\n    query: z.object({\n      search: z.string().optional(),\n      includeDeleted: z.preprocess(\n        (val) => val === \"true\",\n        z.boolean().optional()\n      ),\n    }),\n  },\n  post: {\n    body: z.object({\n      name: z.string().min(1, \"Name is required\"),\n      price: z.number().positive(\"Price must be positive\"),\n    }),\n  },\n};\n\n// Route-specific middleware\nexport const middleware = [\n  async (\n    req: BurgerRequest,\n    res: BurgerResponse,\n    next: () => Promise<Response>\n  ) => {\n    console.log(\"[Product Middleware] Executing product route middleware\");\n    // You could add authentication or logging here\n    return next();\n  },\n];\n\n// GET handler: returns product details\nexport async function GET(\n  req: BurgerRequest,\n  res: BurgerResponse,\n  params: { id: number }\n) {\n  console.log(\"[GET] Product route invoked\");\n  const validatedParams = (req.validated?.params as { id: number }) || params;\n  const query = req.validated?.query || Object.fromEntries(req.query.entries());\n  \n  // In a real app, you would fetch the product from a database\n  return res.json({\n    id: validatedParams.id,\n    query,\n    name: \"Sample Product\",\n    price: 99.99,\n    description: \"This is a sample product\",\n  });\n}\n\n// POST handler: creates a new product\nexport async function POST(req: BurgerRequest, res: BurgerResponse) {\n  console.log(\"[POST] Product route invoked\");\n  const body = req.validated?.body || (await req.json());\n  \n  // In a real app, you would save the product to a database\n  return res.json(body);\n}\n\n// PUT handler: updates a product\nexport async function PUT(\n  req: BurgerRequest,\n  res: BurgerResponse,\n  params: { id: number }\n) {\n  const id = params.id;\n  const body = req.validated?.body || (await req.json());\n  \n  // In a real app, you would update the product in a database\n  return res.json({\n    id,\n    ...body,\n    updated: true,\n  });\n}\n\n// DELETE handler: deletes a product\nexport async function DELETE(\n  req: BurgerRequest,\n  res: BurgerResponse,\n  params: { id: number }\n) {\n  const id = params.id;\n  \n  // In a real app, you would delete the product from a database\n  return res.json({\n    id,\n    deleted: true,\n  });\n}"
}